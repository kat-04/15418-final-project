<!DOCTYPE HTML>
<!--
	Hyperspace by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>3D Conway's Game of Life</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a href="index.html" class="title">3D Conway's Game of Life</a>
				<nav>
					<ul>
						<li><a href="index.html">Home</a></li>
						<li><a href="elements.html">Demo</a></li>
					</ul>
				</nav>
			</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper">
						<div class="inner">
							<h1 class="major">Project Proposal</h1>
                            <h2>Summary</h2>
							<p>We will be implementing different parallel implementations of Conway’s Game of Life in 3D. We will be
                                using the NVIDIA GPUs on the GHC machines for our CUDA implementation and the PSC machines
                                for the OpenMP implementation.</p>
                            <h2>Background</h2>
                            <p>Conway’s Game of Life is a Turing complete zero-player cellular automaton, traditionally in 2D, that
                                simulates basic evolution. After giving an initial configuration of alive or dead cells, the pattern evolves
                                based on a set number of rules governed by the neighbors of each cell:</p>
                            <ol>
                                <li>A cell with <h:math>\leq 1</h:math> living neighbors <i>(underpopulation)</i></li>
                                <li>A cell with <h:math>\geq 4</h:math> living neighbors dies <i>(overpopulation)</i></li>
                                <li>An empty cell with exactly 3 living neighbors becomes alive <i>(reproduction)</i></li>
                            </ol>
                            <p><span class="image right"><img src="images/oscillatorExample.jpg" alt="" /></span>Despite this basic ruleset, there have been many different types of patterns found through studies: still lifes, which do not move; oscillators, which have a periodic form of motion; and spaceships, which drift in a consistent manner across space. Some initial patterns can also lead to infinite growth, where the bounding box of the pattern grows at each timestep. One example of a basic oscillator is shown to the right.</p>
                            <p>Conway's Game of Life is fairly simple in 2D, as there are only 8 neighbors and 2 axes (x- and y-axis). However, adapting to 3D -- increasing the number of neighbors from 8 to 26 and multiplying the size of the grid by another factor -- greatly increases communication intensity. Furthermore, the z-axis can now be an added area of parallelism.</p>
                            <p>Another area for potential speedup is the idea converging or stable structures that form in Conway's Game of Life. In the 2D model, all starting states gradually converged to stable structures. Similarly, in 3D, all starting states will also generally remain stable after a certain time, meaning that there will be no need to pass information about empty spaces around unless they are immediate neighbors.</p>
                            <h2>The Challenge</h2>
                            <p>As stated previously, scaling to 3D increases the areas of parallelism and the achievable theoretical speedup. By increasing the number of dimensions, we increase the number of neighbors (8 to 26), meaning we must do more than 3 times as much communication. Furthermore, the number of cells increase from N<sup>2</sup> to N<sup>3</sup>, potentially creating a memory constraint if N becomes large enough.</p>
                            <p>The main workload of this project revolves around managing locality. Since all computation relies on the state of the neighbors of a cell at any given time, our project has a very high communication-to-computation ratio.</p>
                            <p>There are also constraints to the workload. There are many possible patterns that the cellular structures can stably converge to, as the cells tend to group around their immediate neighbors. This situation immediately gives rise to the possibility of workload imbalance, as areas with alive cells will need to communicate more than areas with only dead cells (note how all the rules for 2D Conway's Game of Life are based on the number of alive neighbors). </p>
                            <h2>Resources</h2>
                            <p>Some basic aspects of our projects 2 (CUDA) and 3 (OpenMP) are naturally similar due to their methods of parallelism, so we will use them as reference. Our past assignments using CUDA kernels and OpenMP pragmas for 2D programs will help us extend our knowledge to a 3D program. </p>
                            <p>We have also found a couple of online resources that will be useful. The first website <a href="https://cs.brown.edu/courses/cs195v/projects/life/edwallac/index.html">here</a> describes some interesting extensions of the original ruleset for the 3D version. Another website  <a href="https://shankarrajagopal.github.io/DOWNLOAD/CG_LAB_P3.pdf">here</a> provides a useful guide to rendering in OpenGL, which we would like to build upon to render our results.</p>
                            <h2>Goals and Deliverables</h2>
                            <h3>Plan to Achieve</h3>
                            <p>We expect to achieve the following tasks within the time frame. Note that all three implementations should output their results in a common text format so that we can judge correctness and easily render results. </p>
                            <ol>
                                <li><u>Sequential Implementation</u> - a naive, sequential implementation of the 3D Game of Life that can be used as a comparison to our parallel implementations. </li>
                                <li><u>Parallel CUDA Implementation</u> - a parallel implementation of the 3D Game of Life in CUDA that achieves significant speedup in comparison to our sequential version. It should work to minimize computation and workload imbalance. </li>
                                <li><u>Parallel OpenMP Implementation</u> - a parallel implementation of the 3D Game of Life in OpenMP that achieves significant speedup in comparison to our sequential version. Similarly, it should work to minimize computation and workload imbalance.</li>
                                <li><u>Visualizations for Debugging Purposes in OpenGL</u> - a basic, non-interactive renderer of our output data that visualizes the cube and each simulation step. This is an important step to ensure correctness of our implementations and it allows for visual debugging.</li>
                            </ol>
                            <h3>Hope to Achieve</h3>
                            <p>While not strictly necessary for this project, we would like to achieve some of the following as well.</p>
                            <ol>
                                <li><u>Parallel MPI Implementation</u> - If we have a siginificant amount of extra time, we would like to create a third parallel implementation based on MPI. It would add to our speedup analysis of our main two parallel implementations. </li>
                                <li><u>Interactive Visualizations in OpenGL</u> - This would expand upon the basic debugging renderer and allow for more interactivity. You would be able to rotate the cube while it simulates and it would be more visually polished. This would be a great way to show off our results.</li>
                                <li><u>Experimentation with Various Rulesets</u> - We would like to try implementing variations on the traditional game ruleset. Not only would this be visually interesting, but it would also allow further analysis of how our code performs more generally. Changing the ruleset can impact the density of living cells, the way in which they group together, and how the simulation changes over time. All of these factors have the potential to impact the performance of our implementations due to changes in workload imbalance and communication costs. </li>
                                <li><u>Integrating OpenGL rendering with our CUDA implementation</u> - CUDA and OpenGL can work well together as they both make significant use of the GPU. OpenGL has the capability to directly access CUDA GPU memory and significantly speed up the rendering process. Our planned implementation does not take advantage of this compatibility. We would like to see how integrating the CUDA simulation and OpenGL rendering code affects performance if we have time. </li>
                            </ol>
                            <h3>Demo</h3>
                            <p>In terms of speedup analysis, we will have graphs that show how our sequential and parallel implementations perform in a variety of scenarios. Varying cube size and starting configurations can all impact performance in different ways. By measuring how each implementation handles these changes, we can provide a more complete picture of our final results. We will also have a small discussion about the relative strengths and weaknesses of both parallel implementations. </p>
                            <p>Visually, we will have at a minimum our simple debugging renderer in OpenGL to showcase some of the simulations. Hopefully, we will have time to polish this a little more for the final demo. </p>
                            <h3>Analysis</h3>
                            <p>This project will help us better our understanding of the relative strengths and weaknesses of OpenMP and CUDA as we analyze our results. Specifically, we will see how these implementations perform large tasks that involve a high communication-to-communication ratio and workload imbalance.</p>
                            <h3>Performance Goals</h3>
                            <p>While concrete speedups for our two implementations are difficult to estimate, we hope to achieve at least a 10x speedup for both the CUDA and OpenMP implementations. In theory each cell could be perfectly parallelized and lead to much more than a 10x improvement, but we predict that high communication costs and workload imbalance will limit our implementations. Thus, 10x speedup is a reasonable goal that shows significant improvement over the sequential implementation while still accounting for limiting factors. </p>
                            <h2>Platform Choice</h2>
                            <p>For the sequential implementation, we will code in C++ and measure it on the PSC machines (CPU). For the CUDA implementation, we will code in CUDA and measure it on the PSC machines (GPU). Finally, for the OpenMP implementation, we will code in OpenMP and measure it on the PSC machines (CPU). The renderer will be made using OpenGL.</p>
                            <h2>Schedule</h2>
                            <div class="table-wrapper">
                                <table class="alt">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <th>Goal</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>March 31</td>
                                            <td>Project proposal done</td>
                                        </tr>
                                        <tr>
                                            <td>April 1-8</td>
                                            <td>Basic visualizations done</td>
                                        </tr>
                                        <tr>
                                            <td>April 9-10</td>
                                            <td>Basic sequential version complete </td>
                                        </tr>
                                        <tr>
                                            <td>April 11-21</td>
                                            <td>Cuda and OpenMP versions done</td>
                                        </tr>
                                        <tr>
                                            <td>April 18</td>
                                            <td>Project Milestone Report</td>
                                        </tr>
                                        <tr>
                                            <td>April 22 - May 4</td>
                                            <td>Work on any stretch goals</td>
                                        </tr>
                                        <tr>
                                            <td>May 4-5</td>
                                            <td>Final report and presentation complete</td>
                                        </tr>
                                    </tbody>
                                    <tfoot>
                                        <tr>
                                            <td colspan="2"></td>
                                        </tr>
                                    </tfoot>
                                </table>
                            </div>
                        </div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper alt">
				<div class="inner">
					<ul class="menu">
						<li>&copy; Untitled. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
